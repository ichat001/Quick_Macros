# 指针、引用和数组

**警告**：错误使用指针可能导致系统不稳定或数据损坏。

**提示**：如果需要使用数组，[安全数组](IDP_OLE_ARRAY.md) 通常是最佳选择。

## 指针变量

指针是一个存储其他变量地址的变量。使用 `&` 操作符获取变量或函数的地址，使用 `*` 操作符访问指针指向的变量。例如：

```qm
;; 声明变量 v
int v = 5
;; 声明指针 p
int* p = &v
;; 现在 p 指向（存储）v 的地址
int a = *p
;; 现在变量 a = 5，等同于 a = v
*p = 10
;; 现在变量 v = 10，等同于 v = 10

;; 将变量 r 的地址传递给 DLL 函数
RECT r
GetWindowRect(win() &r)

;; 将函数 TimerProc 的地址传递给 DLL 函数
timeSetEvent 1000 10 &TimerProc 0 0
```

声明指针变量时，使用其指向变量的类型并附加 `*`。例如，指向 `str` 变量的指针声明为：

```qm
str* p
```

最大间接级别为 3。例如，`int*** p` 有效，但 `int**** p` 会报错。

指针变量类似于 `int` 变量，大小为 4 字节，但被解释为无符号整数。

`*` 操作符也可用于包含的表达式或返回指针的函数。例如：

```qm
*(arr + 2) = 10
int i = *FunctionThatReturnsIntPointer
```

## 数组

指针可以指向变量数组。使用 `[]` 操作符访问数组元素，索引从 0 开始。若指针指向数组，则指向数组的第一个变量（以下表达式成立：`arr == &arr[0]` 和 `*arr == arr[0]`）。将指针加变量大小（如 `arr + sizeof(str)`），则指向数组的下一个变量（`arr == &arr[1]` 和 `*arr == arr[1]`）。

创建数组的方式有以下几种：

1. **使用内置 [内存分配函数](IDP_MEMORY.md) 动态分配数组**：使用 `_new` 或 `_resize` 分配或调整数组大小，使用 `_delete` 释放。这些函数正确构造和析构任何类型的元素。例如：

```qm
str* arr._new(10)
arr[0] = "abc"
str s = arr[9]
...
arr._delete
```

2. **使用其他函数动态分配数组**（如 `calloc`、`LocalAlloc` 等）：

```qm
word* arr = calloc(10 sizeof(word))
...
free arr
```

3. **在 `str` 变量中动态分配数组**：`str` 变量超出作用域时，QM 自动释放此类数组。例如：

```qm
str s.all(10*sizeof(word) 0 0)
word* arr = +s
...
```

4. **声明 n 个局部变量**：

```qm
str s0 s1 s2 s3
str* arr = &s0
...
```

5. **定义包含嵌入数组的变量类型**：

```qm
type LPSTRARRAY50 $s[50]
LPSTRARRAY50 a
lpstr* arr = &a[0]
...
```

6. **使用 [安全数组](IDP_OLE_ARRAY.md)**：无需担心数组初始化和释放。

对于方式 2 和 3，数组元素的构造函数和析构函数不会被调用。对于复合类型（如 `str`）的数组，必须显式初始化数组内存（`calloc` 会自动初始化），并在释放前清空每个元素。例如：

```qm
str* arr = calloc(10 sizeof(str))
...
for(int'i 0 10) arr[i].all
free arr
```

## 引用变量

引用变量存储其他变量的地址，但语法上表现得像该变量。通常在声明时初始化（接收其他变量的地址），之后像普通变量一样使用。对引用变量的操作实际上修改其指向的变量。例如：

```qm
;; 声明变量 v
int v = 5
;; 声明引用 r
int& r = &v
;; 现在 r 是 v 的引用（存储 v 的地址）
int a = r
;; 现在变量 a = 5，等同于 a = v
r = 10
;; 现在变量 v = 10，等同于 v = 10
```

引用变量可以稍后[重新]初始化：

```qm
int& r
int v2=100
&r = &v2 ;; 现在 r 是 v2 的引用
out r ;; 100
```

初始化引用变量时，必须接收其他变量的地址，使用 `&` 操作符获取地址。但若变量类型相同，`&` 可省略，这也适用于函数参数。若需避免此优化，使用 `+` 操作符。例如：

```qm
int v = 5
int& r = &v ;; 正确，r 初始化为 v 的地址
int& r = v ;; 正确，r 初始化为 v 的地址
int& r = +v ;; r 初始化为 v 的值
```

## 使用

引用变量使用更简单（无需 `*`），但指针变量更灵活（可用于数组等）。指针和引用主要用作函数参数，调用者传递变量地址，函数可修改该变量。这常用于 `str`、`ARRAY` 等类型以避免数据复制。

若参数声明为字节指针（`byte*` 或 `!*`），可传递任何类型的指针或字符串，类似于 C++ 的 `void*`。

若赋给指针变量（或参数等）的表达式类型不同，QM 可能报错。使用 [操作符 +](IDP_OPUNARY.md) 可避免错误。

使用指针时，指针应始终指向现有变量或其他有效内存位置。某些函数接受 0，否则可能导致宏以“异常”或“无效指针”错误结束，或 QM 退出、不稳定，或数据损坏。需了解变量的生命周期，因变量超出作用域（销毁）后，指向它的指针将失效。